#' Run townlet donor proliferation analysis
#' @description
#' Runs hierarchical Dirichlet regression model to quantify treatment specific donor proliferation effects and test whether specific donor groups significantly influence growth.
#'
#' @param village Village object generated by townlet::init_village()
#' @param cores Number of cores for sampling
#' @param samples Number of samples (including warmup)
#' @param warmup Number of warmup samples
#' @param chains Number of chains
#' @param credinterval Credible interval for significance testing
#' @param ppck Run posterior predictive check
#' @param priors Set custom priors
#' @param comp If running on server comp=1, else if running on local computer comp=0
#'
#' @returns Updated village object.
#' @export
#'
#' @examples
#' \dontrun{
#'   test_village <- run_townlet(test_village)
#' }
run_townlet <- function(village, cores=1, samples=2e4, warmup=1e4, chains=4, credinterval=0.95, ppck=TRUE, priors=NULL, comp=1) {
  UseMethod("run_townlet")
}
#' @exportS3Method run_townlet Village
run_townlet.Village <- function(village, cores=1, samples=2e4, warmup=1e4, chains=4, credinterval=0.95, ppck=TRUE, priors=NULL, comp=0) {

  ## Check if the object is of class "Village"
  if (!inherits(village, "Village")) {
    stop("Object must be of class 'Village'. Call init_village() before running model.", call. = FALSE)
  }

  # Set model specifications
  print(paste("Credible interval threshold set to: ", credinterval))
  village$credinterval <- credinterval

  if (ppck == TRUE) {
    village$ppck <- 1
  } else{village$ppck <- 0}

  village$mcmc_samples <- samples
  village$mcmc_warmup <- warmup
  village$mcmc_chains <- chains

  # Set model priors
  if (!is.null(priors)) {
    village$priors <- priors
  }

  print('Defining model inputs')
  village <- model_inputs(village)

  village <- def_priors(village)

  print('Setting up stan model')
  village <- modelversion(village)

  print('Running model')
  # server
  if (comp == 1) {
    options(mc.cores = cores)
  }
  # computer
  if(comp == 0) {
    options(mc.cores = parallel::detectCores())
  }

  rstan::rstan_options(auto_write = TRUE)

  tryCatch(
    {village$fit <- rstan::stan(model_code = village$stan,
                                data = village$inputs,
                                chains=chains,
                                warmup = warmup,
                                iter= samples,
                                cores = cores
    )})

  if(village$sim == TRUE) {
    print('Saving model fit')
    filepath <- paste0(village$outdir, village$name, '_fit.RDS')
    saveRDS(village$fit, filepath)
  }

  print('Running model diagnostics')
  village$num_divergent <- rstan::get_num_divergent(village$fit)
  village$num_maxtreedepth <- rstan::get_num_max_treedepth(village$fit)
  village$bfmi <- rstan::get_bfmi(village$fit)

  print(paste('Divergences:', village$num_divergent))
  print(paste('Tree depth:', village$num_maxtreedepth))
  # rstan::check_hmc_diagnostics(village$fit)
  print(village$bfmi)

  print('Generating model summary statistics')
  village <- sumstats(village)

  if (village$sim == FALSE) {

    print('Plotting effective samples size')
    tryCatch(
      {plot_ESS(village)},
      error = function(e) {
        print('ESS Plot Failed: ')
        print(e)}
    )

    print('Plotting model parameters and donor growthrates')
    tryCatch(
      {village <- plot_params(village)},
      error = function(e) {
        print('Param plots failed: ')
        print(e)
        return(NULL)}
    )

    print('Plotting posterior predictive checks')

    tryCatch(
      {village <- plot_ppck(village)},
      error = function(e) {
        print('ppck plot failed: ')
        print(e)
        return(NULL)}
    )
  }

  print('Calculating mean growthmetric per donor for each treatment dose')
  tryCatch(
    {village <- growthmetric(village)},
    error = function(e) {
      print('Calculating growth effect failed: ')
      print(e)
      return(NULL)}
  )

  if(village$sim == FALSE) {
    saveRDS(village, paste0(village$outdir, village$name, '.RDS'))
  }
  return(village)
}


#' Define model inputs
#'
#' Internal generic function to define townlet model inputs based on user provided data and model specifications.
#'
#' @param village A Village object.
#' @return An updated village object.
#' @keywords internal
model_inputs <- function(village) {
  UseMethod("model_inputs")
}
#' @exportS3Method model_inputs Village
model_inputs.Village <- function(village) {
  ## T0 matrix [num_reps, num_donors]
  cols <- c('sample',
            village$treatcol,
            "treatment_scaled",
            "time",
            "time_scaled",
            "replicate",
            'donorid',
            'donor',
            village$donorcov,
            'representation')
  existing_cols <- intersect(cols, names(village$data))
  df <- village$data[, existing_cols]

  if(length(village$treatcol) != 0) {
    village$df_T0 <- df[df$time_scaled == 0, c('sample',
                                               village$treatcol,
                                               'treatment_scaled',
                                               'replicate',
                                               'donorid',
                                               'donor',
                                               'representation')]
  } else{
    village$df_T0 <- df[df$time_scaled == 0, c('sample',
                                               'replicate',
                                               'donorid',
                                               'donor',
                                               'representation')]
  }

  village$df_T0 <- village$df_T0 |>  group_by(sample) |>  mutate(representation = representation - representation[village$num_donors]) |>  ungroup()
  df_T0 <- village$df_T0[, c('sample','donorid','representation')] |>  pivot_wider(id_cols = 'sample', names_from = 'donorid', values_from = 'representation')

  if(any(is.na(df_T0[,-1]))) {
    na_rows <- which(rowSums(is.na(df_T0[-1])) > 0)
    na_samples <- df_T0$sample[na_rows]
    stop(paste('Donor values missing in T0 samples', paste(na_samples, collapse = ', ')))
  }

  village$T0 <- as.matrix(df_T0[,-1])

  # Check that all donors present in T0
  if (ncol(village$T0) != village$num_donors) {
    stop("Donors missing from time 0 data")
  }

  # Check for replicate structure of T0 data
  if (nrow(village$T0) != village$num_reps) {
    if (nrow(village$T0 == 1)) {
      village$T0 <- village$T0[rep(1, times=village$num_reps*village$num_timepts),]
      warning("Using the same T0 values for all replicates!")
    } else {
      stop("Incorrect number of samples in time 0 data")
    }
  } else {
    village$T0 <- village$T0[rep(1:village$num_reps, times=village$num_timepts),]
  }

  ## N = total # samples (num_reps*num_doses*num_timepts--excluding T0)
  ## Y = sample proportion matrix [N, num_donors]

  village$data_noT0 <- df[df$time_scaled != 0, ]

  village$data_noT0 <- village$data_noT0 |> dplyr::group_by(sample) |>  dplyr::mutate(sample=dplyr::cur_group_id())
  village$data_noT0 <- village$data_noT0[order(village$data_noT0$sample),]
  cols <- setdiff(existing_cols, c("donor", "donorid", "representation", village$donorcov))
  df <- village$data_noT0[,c(cols, 'donorid', 'representation')] |>
    pivot_wider(id_cols = all_of(cols), names_from = 'donorid', values_from = 'representation')

  village$N = length(df$sample)

  if(village$N != village$num_reps*(village$num_timepts)) {
    stop(paste('Missing samples from data. Expecting:', village$num_reps*village$num_timepts, 'samples, only', village$N, 'samples present.'))
  }
  if(any(is.na(df[, !(names(df) %in% cols)]))) {
    na_rows <- which(rowSums(is.na(df[, !(names(df) %in% cols)])) > 0)
    na_samples <- df$sample[na_rows]
    stop(paste('Donor values missing in samples', paste(na_samples, collapse = ', ')))
  }

  village$Y <- as.array(as.matrix(df[, !colnames(df) %in% cols]))
  if(ncol(village$Y) != village$num_donors) {
    stop('Missing donors from data')
  }

  ## time_indx of samples (vector length N)
  village$time_indx <- as.vector(df$time_scaled)

  ## rep_indx of samples (vector length N)
  village$rep_indx <- as.vector(df$replicate)

  #Set up z_d matrix
  if (!is.null(village$model)) {
    if (length(village$treatcol) == 1) {
      if(length(village$donorcov[grepl('treatment_', village$donorcov)]) >0) {
        treat_original <- village$donorcov[grepl('treatment_', village$donorcov)]
        treat_interact <- str_remove(treat_original, village$treatcol) |>
          str_remove(":")
        treat_interact <- paste(treat_interact, 'treatment_scaled', sep = ':')
        village$model <- paste0('~ ', paste(c('treatment_scaled', village$donorcov[!(village$donorcov %in% treat_original)], treat_interact), collapse = ' + '))
      } else {
        village$model <- paste0('~ ', paste(c('treatment_scaled', village$donorcov), collapse = ' + '))
      }
    }

    village$z_d <- model.matrix(as.formula(village$model), data=village$data_noT0)
    village$P <- ncol(village$z_d)

    # Check if matrix is full rank
    rank <- qr(village$z_d)$rank
    if(rank != ncol(village$z_d)) {
      stop('Model identity matrix is not full rank.')
    }
  } else {
    village$z_d <- matrix(1, nrow = village$num_donors*village$N, ncol = 1)
    village$P <- 1
  }

  return(village)
}


#' Define model priors
#'
#' Internal generic function that sets model priors. Dispersion variances are set by applying an empirical Bayes approach.
#'
#' @param village A Village object.
#' @return An updated village object.
#' @keywords internal
def_priors <- function(village) {
  UseMethod("def_priors")
}
#' @exportS3Method def_priors Village
def_priors.Village <- function(village) {

  # Model priors
  if(length(village$treatcol) == 0 & (isTRUE(village$ebayes) | is.null(village$priors))) {
    if (village$num_timepts == 1) {
      phi_intercept <- 8
      phi_slope <- 0
    } else {
      # empirical Bayes
      df <- village$data |> select(donor, time, replicate, representation)
      df$i <- 1

      if(village$sim == FALSE & nrow(df[df$time ==0,]) != village$num_reps) {
        df_0 <- dplyr::bind_rows(replicate(village$num_reps, df[df$time ==0,], simplify = FALSE))
        df_0$replicate <- rep(1:village$num_reps, each = village$num_donors)
        df <- df[df$time != 0,]
        df <- rbind(df, df_0)
        df <- df[order(df$time),]
      }

      data <- df |>
        select(i, time, replicate, donor, representation) |>
        pivot_wider(names_from = donor, values_from = representation)

      # Fitting frequentist Dirichlet
      df_freqdir <- data |>
        group_by(i) |>
        group_modify(~ {
          # Set up data
          response_data <- .x[, !(colnames(.x) %in% c("time", "replicate"))]
          pred_data <- .x[, c("time", "replicate")]

          if (nrow(response_data) == 0) {
            return(data.frame(value = NA_real_, param = NA_character_, donor = NA_real_))
          }

          # Fit model
          result <- tryCatch({

            smp <- DirichletReg::DR_data(response_data,
                                         base = village$num_donors)
            fit <- DirichletReg::DirichReg(
              formula = smp ~ time | 1,
              data = pred_data,
              model = 'alternative'
            )

            # Extract fit parameters
            params <- unlist(coef(fit)) |> as.data.frame()
            params$param <- rownames(params)
            params

          }, error = function(e) {
            warning(paste("Error in group:", paste(names(.y), .y, sep = "=", collapse = ", "), "\nError message:", e$message))
            data.frame(value = NA_real_, param = NA_character_, donor = NA_real_)
          })

          return(result)
        })

      phi_intercept <- round(df_freqdir$`unlist(coef(fit))`[df_freqdir$param == 'gamma.gamma.(Intercept)'], 3)
      betad_mean <- abs(df_freqdir$`unlist(coef(fit))`[df_freqdir$param != 'gamma.gamma.(Intercept)'])*5

      print('Using empirical bayes to estimate dispersion')
    }
  }

  if(length(village$treatcol) == 1 & (isTRUE(village$ebayes) | is.null(village$priors))) {
    # empirical bayes
    df <- village$data[, c('donor', 'time_scaled', 'replicate', 'representation', 'treatment_scaled')]
    df <- pivot_wider(df, id_cols = c('time_scaled', 'replicate', 'treatment_scaled'),names_from = 'donor', values_from = 'representation')
    df$Y <- DirichletReg::DR_data(df[,4:ncol(df)])

    tryCatch(
      {model <- DirichletReg::DirichReg(Y ~ treatment_scaled + time_scaled | time_scaled, data=df, model= 'alternative')
      model_summary <- summary(model)
      phi_intercept <- model_summary$coefficients[startsWith(names(model_summary$coefficients), '(phi):(Intercept)')]
      phi_slope <- model_summary$coefficients[startsWith(names(model_summary$coefficients), '(phi):time_scaled')]
      }, error = function(e) {
        print(paste('Error in DirichletReg model fitting:', e$message))
        print('Using default phi priors')
        phi_intercept <<- 8
        phi_slope <<- 2
      }
    )
  }

  # define priors
  default_priors <- list(phi_mean = 0,
                         phi_var = 2,
                         phi_r_var = 5,
                         theta_mean = phi_intercept,
                         theta_var = 2,
                         beta_var = 1,
                         tau_g_var= 2,
                         tau_d_var = 0.5)
  prnames <- names(default_priors)


  # Check user defined priors
  if(!is.null(village$priors)) {
    if (is.null(names(village$priors))) {
      stop("Please provide all model priors as a named list")
    }
    if(isTRUE(village$ebayes)) {
      village$priors$phi_mean = 0
      village$priors$theta_mean = phi_intercept
    }
    actual_names <- names(village$priors)
    missing_names <- setdiff(prnames, actual_names)
    if(length(missing_names) > 0) {
      stop(paste0('Missing the following priors: ', paste(missing_names, collapse = ', ')))
    }
  } else {
    village$priors <- default_priors
  }

  return(village)
}

#' Define townlet model
#'
#' Internal generic function that selects the appropriate townlet model version based on user provided model specifications.
#'
#' @param village A Village object.
#' @return An updated village object.
#' @keywords internal
modelversion <- function(village) {
  UseMethod("modelversion")
}
#' @exportS3Method modelversion Village
modelversion.Village <- function(village) {
  ## Define version
  #%%%% Add model inputs attribute %%%%

  village$inputs <- list(N=village$N,
                         D=village$num_donors,
                         R=village$num_reps,
                         P=village$P,
                         x_t=village$time_indx,
                         rep_indx= village$rep_indx,
                         z_d=village$z_d,
                         alpha = village$T0,
                         Y=village$Y,
                         phi_mean=village$priors[['phi_mean']],
                         phi_var=village$priors[['phi_var']],
                         phi_r_var=village$priors[['phi_r_var']],
                         theta_mean=village$priors[['theta_mean']],
                         theta_var=village$priors[['theta_var']],
                         beta_var=village$priors[['beta_var']],
                         tau_g_var= village$priors[['tau_g_var']])

  if (length(village$treatcol) == 0) {
    village$stan <- "
          data {
              int<lower=0> N; // # of samples
              int<lower=0> D; // # of donors
              int<lower=0> R; // # of replicates
              int<lower=0> P; // # of predictors
              vector[N] x_t; // time(psg) indx across all samples
              array[N] int<lower=0> rep_indx; // replicate index for pooled technical noise parameter phi
              matrix[D*N,P] z_d; // predictors
              matrix[N,D] alpha; // time 0 representaton values
              matrix[N,D] Y; // response variable: donor representation matrix

              // Set priors

              //overdispersion priors
              real phi_mean;
              real phi_var;
              real phi_r_var;
              real theta_mean;
              real theta_var;

              // growthrate priors
              real beta_var;
              real tau_g_var;
          }

          parameters {
              // overdispersion params
              real<lower=0> theta0; // technical variation at T0
              real phi; // time effect prior on technical variation
              vector[R] phi_r; // time effect on technical variation partially pooled by replicate

              // growthrate params
              vector[D-1] beta_raw; // untransformed donor baseline proliferation effect
              matrix[P-1, 1] tau_g; // donor covariates
              real<lower=0> beta_rawvar; // beta variance
          }
          transformed parameters {
              // partially pooling technical variation slope by replicate
              vector[N] vphi_r;
              for (n in 1:N){
                vphi_r[n] = phi_r[rep_indx[n]];
              }

              // define technical variation of each sample
              vector[N] exptheta;

              for (n in 1:N){
                exptheta[n] = exp(theta0 + x_t[n] * vphi_r[n]);
              }

              // Set baseline donor
              vector[D] beta;
              beta[D] = 0.0;

              // transform growth rates to include baseline donor
              for (d in 1:(D-1)) {
                  beta[d] = beta_raw[d];
              }
          }
          model {
              phi ~ normal(phi_mean, phi_var);
              theta0 ~ normal(theta_mean, theta_var);

              // sample time effect on technical variation patially pooled by replicate
              for (r in 1:R) {
                phi_r[r] ~ normal(phi, phi_r_var);
              }

              beta_rawvar ~ cauchy(0,beta_var);

              // sample donor growth rates
              for(d in 1:(D-1)) {
                  beta_raw[d] ~ normal(0, beta_rawvar);
                }

              // sample donor covariate effects
              if(P > 1) {
                  for(i in 1:P-1){
                      tau_g[i,1] ~ cauchy(0, tau_g_var);
                  }
              }

              // likelihood
              for(n in 1:N){
                  vector[D] eta;
                  for(d in 1:D) {
                      if(P > 1){
                          eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2:P] * tau_g[,1]);
                      } else {
                          eta[d] = alpha[n,d] + x_t[n] * beta[d];
                      }
                  }
                  transpose(Y[n,]) ~ dirichlet(softmax(eta) * exptheta[n]);
              }
          }

          "

    if(village$ppck == TRUE) {
      village$stan <- c(village$stan, "
            generated quantities{
                matrix[D,N] post_prck; // posterior predictive check
                // matrix[D,N] post_pred; // posterior predictions (given covariates estimate obsv)
                for(n in 1:N){
                    vector[D] eta;
                    // vector[D] eta_pp;
                    for(d in 1:D) {
                        if(P > 1){
                            eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2:P] * tau_g[,1]);
                        } else {
                            eta[d] = alpha[n,d] + x_t[n] * beta[d];
                        }
                    }
                    post_prck[,n] = dirichlet_rng(softmax(eta) * exptheta[n]);
                // post_pred[,n] = dirichlet_rng(softmax(eta_pp) * exptheta[1,n]);
                }
            }

            ")
    }
  } else {
    print('Running model with donor specific treatment effects')
    village$inputs <- c(village$inputs, tau_d_var=village$priors[['tau_d_var']])

    village$stan <- "
            data {
                int<lower=0> N; // number samples
                int<lower=0> D; // number donors
                int<lower=0> R; // number replicates
                int<lower=0> P; // number predictors
                vector[N] x_t; // time(psg) indx across all samples
                array[N] int<lower=0> rep_indx; // replicate index for pooled technical noise parameter phi
                matrix[D*N,P] z_d; // predictors
                matrix[N,D] alpha; // time 0 representaton values
                matrix[N,D] Y; // response variable: donor representation matrix

                // Set priors

                //overdispersion priors
                real phi_mean;
                real phi_var;
                real phi_r_var;
                real theta_mean;
                real theta_var;

                // growthrate priors
                real beta_var;
                real tau_g_var;
                real tau_d_var;
            }

            parameters {
                // overdispersion params
                real theta0; // technical variation at T0
                real phi; // time effect prior on technical variation
                vector[R] phi_r; // time effect on technical variation partially pooled by replicate

                // growthrate params
                vector[D-1] beta_raw; // untransformed donor growth rates
                matrix[P-2, 1] tau_g; // growth covariates
                real<lower=0> beta_rawvar; // beta variance
                vector[D] tau_d; // treatment effect per donor

            }
            transformed parameters {
                // partially pooling technical variation slope by replicate
                vector[N] vphi_r;
                for (n in 1:N){
                  vphi_r[n] = phi_r[rep_indx[n]];
                }

                // define technical variation of each sample
                vector[N] exptheta;

                for (n in 1:N){
                  exptheta[n] = exp(theta0 + x_t[n] * vphi_r[n]);
                }

                // Set baseline donor
                vector[D] beta;
                beta[D] = 0.0;

                // transform growth rates to include baseline donor
                for (d in 1:(D-1)) {
                    beta[d] = beta_raw[d];
                }
            }
            model {
                phi ~ normal(phi_mean, phi_var);
                theta0 ~ normal(theta_mean, theta_var);

                // sample time effect on technical variation patially pooled by replicate
                for (r in 1:R) {
                  phi_r[r] ~ normal(phi, phi_r_var);
                }

                // baseline donor proliferation
                beta_rawvar ~ cauchy(0,beta_var);

                // sample donor baeline proliferation effect
                for(d in 1:(D-1)) {
                    beta_raw[d] ~ normal(0, beta_rawvar);
                  }

                // sample donor covariate effects
                if (P > 2) {
                    for(i in 1:P-2){
                        tau_g[i,1] ~ cauchy(0, tau_g_var);
                    }
                }

                // sample treatment effects
                for(d in 1:(D)) {
                    tau_d[d] ~ cauchy(0, tau_d_var);
                }

                // likelihood
                for(n in 1:N){
                    vector[D] eta;
                    for(d in 1:D) {
                        if(P < 3){
                            eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2] * tau_d[d]);
                        } else {
                            eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2] * tau_d[d] + z_d[d +(n-1)*D,3:P] * tau_g[,1]);
                        }
                    }
                    transpose(Y[n,]) ~ dirichlet(softmax(eta) * exptheta[n]);
                }
            }
          "

    if(village$ppck == TRUE) {
      village$stan <- c(village$stan, "
                     generated quantities{
                          matrix[D,N] post_prck; // posterior predictive check
                          // matrix[D,N] post_pred; // posterior predictions (given covariates estimate obsv)
                          for(n in 1:N){
                              vector[D] eta;
                              // vector[D] eta_pp;
                              for(d in 1:D) {
                                  if(P < 3){
                                      eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2] * tau_d[d]);
                                  } else {
                                      eta[d] = alpha[n,d] + x_t[n] * (beta[d] + z_d[d +(n-1)*D,2] * tau_d[d] + z_d[d +(n-1)*D,3:P] * tau_g[,1]);
                                  }
                              }
                           post_prck[,n] = dirichlet_rng(softmax(eta) * exptheta[n]);
                          // post_pred[,n] = dirichlet_rng(softmax(eta_pp) * exptheta[1,n]);
                          }
                      }

                          ")
    }
  }

  return(village)
}

#' Model summary statistics
#'
#' Internal generic function that generates model parameters summary statistics.
#'
#' @param village A Village object.
#' @return An updated village object.
#' @keywords internal
sumstats <- function(village) {
  UseMethod("sumstats")
}
#' @exportS3Method sumstats Village
sumstats.Village <- function(village) {
  sumstats <- rstan::summary(village$fit, include_warmup = FALSE)$summary |>  as.data.frame()
  sumstats$paramname <- row.names(sumstats)
  if(village$ppck == 1) {
    village$summary_ppck <- sumstats[startsWith(sumstats$paramname, 'post_'),]
  }
  village$summary_params <- sumstats[!startsWith(sumstats$paramname, 'post_'),]

  return(village)
}


#' Define model priors
#'
#' Internal generic function that calculates total donor proliferation effects.
#'
#' @param village A Village object.
#' @return An updated village object.
#' @keywords internal
growthmetric <- function(village) {
  UseMethod("growthmetric")
}
#' @exportS3Method growthmetric Village
growthmetric.Village <- function(village) {
  cols <- c('donor', 'donorid')
  df_donor <- village$data_noT0[, cols]


  if (village$num_donorcov > 0) {
    if (length(village$treatcol) > 0) {
      df_donor <- cbind(df_donor, village$z_d[,-1:-2])
    } else {
      df_donor <- cbind(df_donor, village$z_d[,-1])
    }

    colnames(df_donor)[3:ncol(df_donor)] <- village$donorcov
  }
  df_donor <- df_donor |>
    dplyr::distinct(across(all_of(colnames(df_donor))))

  df <- data.frame(beta=village$summary_params$mean[startsWith(village$summary_params$paramname, 'beta[')],
                   donorid= village$summary_params$paramname[startsWith(village$summary_params$paramname, 'beta[')])
  df$donorid <- df$donorid |> str_remove('.*\\[') |> str_remove('\\]') |> as.integer()

  df <- merge(df_donor, df, by='donorid')
  df$gr_control <- df$beta

  if(village$num_donorcov > 0){
    for (d in 1:length(village$donorcov)) {
      df[, paste0('dcov_', village$donorcov[d])] <-
        village$summary_params$mean[startsWith(village$summary_params$paramname, paste0('tau_g[', d, ',1]'))]
      df$gr_control <- df$gr_control + df[, paste0('dcov_', village$donorcov[d])] * df[, paste0(village$donorcov[d])]
    }
  }

  if(length(village$treatcol) == 1){
    dosescaled <- unique(village$data$treatment_scaled)
    doses <- village$doses[order(village$doses)]
    df_treat <- data.frame(beta_treat=village$summary_params$mean[startsWith(village$summary_params$paramname, 'beta_treat')],
                           donorid= village$summary_params$paramname[startsWith(village$summary_params$paramname, 'beta_treat')])
    df_treat$donorid <- df_treat$donorid |> str_remove('.*\\[') |> str_remove('\\]') |> as.integer()

    df <- merge(df, df_treat, by='donorid')
    for (d in 1:village$num_doses) {
      df[, paste0('gr_', village$treatment, '_dose', doses[d])] <- df$gr_control + df$beta_treat * dosescaled[d]
      if(doses[d] > 0) {
        df[, paste0('beta_', village$treatment, '_dose', doses[d])] <- df$beta_treat * dosescaled[d]
      }
    }
    village$df_growtheffect <- df[, c('donor', 'donorid', colnames(df)[startsWith(colnames(df), paste0('gr_', village$treatment))])]
  } else {
    village$df_growtheffect <- df |>
      select(donor, donorid, starts_with('gr_')) |>
      distinct()
  }
  return(village)
}

#' Extract draws for eta
#'
#' Internal generic function that extracts donor specific proliferation effect parameter draws for plotting and significance testing.
#'
#' @param village A Village object.
#' @return A list of draws data frames (for control (beta) and optional treatment (tau_d) donor specific parameters).
#' @keywords internal
extract_eta <- function(village) {
  UseMethod("extract_eta")
}
#' @exportS3Method extract_eta Village
extract_eta.Village <- function(village) {
  df_cont <- rstan::extract(village$fit,
                            pars= village$summary_params$paramname[startsWith(village$summary_params$paramname, 'beta[')],
                            permuted=FALSE) |>  as.data.frame()
  df_cont <- pivot_longer(df_cont, cols=1:ncol(df_cont))
  df_cont$donorid <- stringr::str_remove(df_cont$name, '.*\\[') |>  str_remove("\\]") |>  as.numeric()
  df_cont$name <- 'beta'

  if (length(village$treatcol) != 0) {
    df_treat <- rstan::extract(village$fit,
                               pars= village$summary_params$paramname[startsWith(village$summary_params$paramname,'tau_d')],
                               permuted=FALSE) |>  as.data.frame()
    df_treat <- pivot_longer(df_treat, cols=1:ncol(df_treat))
    df_treat$donorid <- stringr::str_remove(df_treat$name, '.*\\[') |>  str_remove("\\]") |>  as.numeric()
    df_treat$name <- paste0('tau[d,', village$treatment, ']')

    df_all <- rbind(df_cont,df_treat)
    rtrnlst <- list(df_all, df_treat, df_cont)

  } else {
    df_all <- df_cont
    rtrnlst <- list(df_all, df_cont)
  }

  return(rtrnlst)
}

